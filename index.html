<meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Oscar‚Äôs Website</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header>
    <h1>Hello, I‚Äôm Oscar üëã</h1>
    <p>Welcome to my personal website!</p>
  </header>

  <main>
    <section>
      <h2>About Me</h2>
      <p>I study empirical economics at Waseda University. I love data, policy, and creative research.</p>
    </section>

    <section>
      <h2>Projects</h2>
      <ul>
        <li>Public Space Friendliness Study (Tokyo)</li>
        <li>ESG Investment & Governance Analysis</li>
        <li>Comparative Political Economy Essay</li>
      </ul>
    </section>

    <section>
      <h2>Sequential Consumer Game</h2>
      <p>
        I built a chess-like Python simulation that pits a retailer against
        multiple consumer segments. Each turn the retailer makes the opening move
        (adjusting price and marketing), then the consumer "pieces" respond in
        sequence with probabilistic purchases and loyalty shifts.
      </p>
      <p>
        The script narrates the rules, plays through the turns, and prints a
        score table showing revenue, cost, and profit so you can interpret the
        strategic flow.
      </p>
      <ol>
        <li>Open the repository on GitHub and start a Codespace or the web editor.</li>
        <li>In the integrated terminal, run <code>python consumer_game.py</code>
          (or <code>python3 consumer_game.py</code>).</li>
        <li>Watch the narrated turns and tweak the segment profiles or strategy to
          explore new openings.</li>
      </ol>
      <p class="note">
        Any Python 3.8+ runtime works locally or on GitHub; the demo requires no
        additional packages.
      </p>
    </section>

    <section>
      <h2>Contact</h2>
      <p>Email: ozhao8509@email.com</p>
    </section>
  </main>
      <a href="china-ngo-localization-20251022.pptx" class="btn" download>üìÇ View Presentation</a>
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sequential Consumer Game (Browser Version)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>

  <style>
    :root{
      --bg:#f7f7f7; --ink:#111827; --muted:#6b7280; --card:#ffffff; --line:#e5e7eb;
      --accent:#2563eb; --accent-2:#0ea5e9;
    }
    body{ margin:0; background:var(--bg); color:var(--ink); font:16px/1.45 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial; }
    .wrap{ max-width: 980px; margin: 32px auto; padding: 0 16px; }
    h1{ font-size: 32px; margin: 0 0 10px; }
    p.muted{ color:var(--muted); margin-top:6px; }
    .panel{ display:grid; grid-template-columns: 1.1fr .9fr; gap: 16px; margin: 18px 0; }
    .card{
      background:var(--card); color:var(--ink); padding:16px; border-radius:14px;
      box-shadow:0 8px 24px rgba(0,0,0,.08); border:1px solid var(--line);
    }
    label{ display:block; font-size:14px; margin:10px 0 4px; }
    input[type="range"]{ width:100%; }
    input[type="number"], select{ padding:6px 8px; border:1px solid var(--line); border-radius:8px;}
    .row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .row > div{ display:flex; align-items:center; gap:8px; }
    .switch{ display:flex; align-items:center; gap:8px; margin-top:8px; }
    button{
      background:var(--accent); color:#fff; border:0; padding:10px 14px; border-radius:10px;
      cursor:pointer;
    }
    button.secondary{ background:var(--accent-2); }
    button:hover{ filter:brightness(1.07); }

    table{ width:100%; border-collapse:collapse; margin-top:6px; }
    th,td{ padding:8px 10px; border-bottom:1px solid var(--line); text-align:left; }
    th{ font-weight:600; }

    #chartWrap, #sensWrap, #diffWrap, #mcWrap{
      background:var(--card); border:1px solid var(--line); border-radius:14px; padding:12px;
    }

    @media (max-width: 900px){ .panel{ grid-template-columns: 1fr; } }
    .stat{ display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:10px; }
    .stat .tile{ background:#fafafa; border:1px solid var(--line); border-radius:10px; padding:10px; }
    .stat .k{ font-size:12px; color:var(--muted); }
    .stat .v{ font-weight:600; font-size:18px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Sequential Consumer Game (Browser Version)</h1>
    <p class="muted">Adjust rounds, price, and marketing; includes competitor, influencer, supplier, investor, and market trend roles. Everything runs client-side on GitHub Pages.</p>

    <!-- Controls + Last Round Summary -->
    <div class="panel">
      <div class="card">
        <div class="row">
          <div style="flex:1">
            <label>Rounds: <span id="roundsVal">20</span></label>
            <input id="rounds" type="range" min="5" max="100" value="20" oninput="roundsVal.textContent=this.value">
          </div>
          <div style="flex:1">
            <label>Start Price: <span id="priceVal">9.5</span></label>
            <input id="startPrice" type="range" min="3" max="25" step="0.1" value="9.5" oninput="priceVal.textContent=this.value">
          </div>
        </div>

        <div class="row">
          <div style="flex:1">
            <label>Start Marketing: <span id="mktVal">0.60</span></label>
            <input id="startMkt" type="range" min="0" max="1" step="0.01" value="0.60" oninput="mktVal.textContent=this.value">
          </div>
          <div class="row">
            <button onclick="runSim()">Run Simulation</button>
          </div>
        </div>

        <hr style="border:none;border-top:1px solid var(--line);margin:14px 0">

        <!-- Role toggles -->
        <div class="row">
          <div class="switch">
            <input type="checkbox" id="useCompetitor" checked>
            <label for="useCompetitor">Competitor (price competition)</label>
          </div>
          <div>
            <label>Competitor Intensity</label>
            <input id="compIntensity" type="range" min="0" max="0.08" step="0.005" value="0.04">
          </div>
        </div>

        <div class="row">
          <div class="switch">
            <input type="checkbox" id="useInfluencer" checked>
            <label for="useInfluencer">Influencer buzz</label>
          </div>
          <div>
            <label>Buzz Strength</label>
            <input id="buzzStrength" type="range" min="0" max="0.3" step="0.01" value="0.15">
          </div>
        </div>

        <div class="row">
          <div class="switch">
            <input type="checkbox" id="useSupplier" checked>
            <label for="useSupplier">Supplier cost</label>
          </div>
          <div>
            <label>Mean Cost</label>
            <input id="supplierMean" type="number" step="0.1" value="1.0">
          </div>
          <div>
            <label>Volatility</label>
            <input id="supplierVol" type="number" step="0.05" value="0.2">
          </div>
        </div>

        <div class="row">
          <div class="switch">
            <input type="checkbox" id="useInvestor" checked>
            <label for="useInvestor">Investor confidence feedback</label>
          </div>
          <div>
            <label>Confidence decay</label>
            <input id="confDecay" type="range" min="0" max="0.2" step="0.01" value="0.05">
          </div>
        </div>

        <div class="row">
          <div class="switch">
            <input type="checkbox" id="useTrend" checked>
            <label for="useTrend">Market trend shocks</label>
          </div>
        </div>
      </div>

      <div class="card">
        <b>Last Round Summary</b>
        <table id="summary">
          <thead><tr><th>Metric</th><th>Value</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <!-- Main Chart -->
    <div id="chartWrap"><canvas id="chart" height="140"></canvas></div>

    <!-- Monte Carlo Averaging -->
    <div class="card" style="margin-top:14px">
      <div class="row" style="justify-content:space-between;">
        <div><b>Monte Carlo Averaging (reduce randomness)</b></div>
        <div class="muted">Runs multiple simulations with current settings; shows mean profit per round and ¬±1œÉ band.</div>
      </div>
      <div class="row" style="margin-top:10px">
        <div>
          <label>Runs (R)</label>
          <input id="mcRuns" type="number" min="5" max="500" step="5" value="60">
        </div>
        <button class="secondary" onclick="runMonteCarlo()">Run Monte Carlo</button>
      </div>

      <div class="stat" style="margin-top:10px">
        <div class="tile"><div class="k">Mean of Avg Profit</div><div class="v" id="mcMean">‚Äî</div></div>
        <div class="tile"><div class="k">Std of Avg Profit</div><div class="v" id="mcStd">‚Äî</div></div>
        <div class="tile"><div class="k">5th Percentile</div><div class="v" id="mcP05">‚Äî</div></div>
        <div class="tile"><div class="k">95th Percentile</div><div class="v" id="mcP95">‚Äî</div></div>
      </div>

      <div id="mcWrap" style="margin-top:10px">
        <canvas id="mcChart" height="140"></canvas>
      </div>
    </div>

    <!-- Round Analyzer -->
    <div class="card" style="margin-top:14px">
      <div class="row" style="justify-content:space-between;">
        <div><b>Round Analyzer</b></div>
        <div class="muted">Choose a round as the baseline; we compute differences to all other rounds and highlight it.</div>
      </div>
      <div class="row" style="margin-top:10px">
        <div>
          <label for="roundSelect">Select round</label>
          <select id="roundSelect"></select>
        </div>
        <button onclick="analyzeSelectedRound()">Analyze Round</button>
      </div>
      <div id="diffWrap" style="margin-top:10px">
        <canvas id="diffChart" height="140"></canvas>
      </div>
    </div>

    <!-- Sensitivity Analysis (kept) -->
    <div class="card" style="margin-top:14px">
      <div class="row" style="justify-content:space-between;">
        <div><b>Sensitivity Analysis</b></div>
        <div class="muted">Varies key role parameters (low/mid/high), averages 20 runs per scenario, and compares average profit.</div>
      </div>
      <div class="row" style="margin-top:10px">
        <button onclick="runSensitivity()">Run Sensitivity</button>
      </div>
      <div id="sensWrap" style="margin-top:10px"><canvas id="sensChart" height="140"></canvas></div>
    </div>

    <div class="card" style="margin-top:14px">
      <details open>
  <summary><b>About the model</b></summary>

  <h4>1) Core idea</h4>
  <p>
    A retailer chooses <i>price</i> and <i>marketing</i> each round. Two consumer segments (A: price-sensitive, B: brand-loyal) decide to buy.
    Optional roles‚ÄîCompetitor, Influencer Buzz, Supplier Cost, Investor Confidence, and Market Trend‚Äîmodify demand or costs.
  </p>

  <h4>2) Equations (per round)</h4>
  <pre style="white-space:pre-wrap">
Demand per segment:
  P(buy) = base + mktSens * effectiveMarketing ‚àí priceSens * (price ‚àí competitorAdj) + trendEffect
  0 ‚â§ P(buy) ‚â§ 1   (clamped)

Buyers per segment ‚âà Binomial(100, P(buy))   ‚Üí  TotalBuyers = buyers_A + buyers_B

Profit:
  Profit = (price ‚àí supplierCost) * TotalBuyers ‚àí 50 * marketing

Competitor adjustment (if enabled):
  competitorAdj = competitorPrice * (1 + compIntensity * 10)
  (Stronger intensity magnifies the penalty for pricing above the competitor.)

Influencer buzz (if enabled):
  effectiveMarketing = marketing + buzzStrength * (TotalBuyers(previous round) / 200)

Supplier cost (if enabled):
  supplierCost ~ mean(supplierMean) ¬± supplierVol   (clamped ‚â• 0)

Investor confidence (if enabled):
  If profit < recent 5-round average ‚Üí confidence decreases ‚Üí marketing scaled down.
  Else confidence edges up slightly.

Market trend (if enabled):
  trendEffect ‚àà { boom:+0.05, stable:0.00, recession:‚àí0.10 } drawn each round.
  </pre>

  <h4>3) Roles and intuition</h4>
  <ul>
    <li><b>Competitor</b>: increases demand penalty when your price exceeds theirs; higher <code>compIntensity</code> ‚Üí higher price sensitivity.</li>
    <li><b>Influencer Buzz</b>: converts last round‚Äôs buyers into extra ‚Äúfree marketing.‚Äù Good performance can snowball (but variance rises).</li>
    <li><b>Supplier Cost</b>: random per round; higher mean/volatility compress margins and widens the profit spread.</li>
    <li><b>Investor Confidence</b>: adaptive brake on marketing after weak profit; narrows downside but can mute rebounds.</li>
    <li><b>Market Trend</b>: boom/recession shocks shift demand baseline and add macro volatility.</li>
  </ul>

  <h4>4) Reading the charts</h4>
  <ul>
    <li><b>Main chart</b>: Profit & Total Buyers over time for one run (shows path-dependence/volatility).</li>
    <li><b>Round Analyzer</b>: Pick a round and see ŒîProfit/ŒîBuyers vs others to diagnose highs/lows.</li>
    <li><b>Monte Carlo (Mean ¬± 1œÉ)</b>: Repeats the same settings many times; plots mean profit per round with an uncertainty band.
      Tiles show the distribution of <i>average profit per run</i> (mean, std, 5‚Äì95%).</li>
    <li><b>Sensitivity</b>: Sweeps one role at a time (low/mid/high) and compares average profit across many runs.</li>
  </ul>

  <h4>5) Insights from multiple runs</h4>
  <ul>
    <li><b>Competition</b>: Higher <code>compIntensity</code> lowers mean profit and raises variance unless price stays close to the competitor.</li>
    <li><b>Marketing & Buzz</b>: There‚Äôs a sweet spot‚Äîmarketing has cost (‚âà 50√ómarketing). With buzz, the mean often rises but the œÉ band widens.</li>
    <li><b>Cost structure</b>: Raising <code>supplierMean</code> shifts profit downward nearly one-for-one; higher <code>supplierVol</code> inflates risk.</li>
    <li><b>Investor confidence</b>: Usually tightens the distribution (lower œÉ) by cutting marketing after weak rounds; peaks may be slightly lower.</li>
    <li><b>Trend shocks</b>: Add macro noise‚Äîboom improves profit, recession lowers it; turning trend OFF helps isolate policy changes.</li>
  </ul>

  <h4>6) Practical tuning workflow</h4>
  <ol>
    <li>Pick a baseline ‚Üí run <b>Monte Carlo</b> (e.g., R=60). Note Mean, œÉ, 5‚Äì95% of average profit.</li>
    <li>Use <b>Sensitivity</b> to find promising levers:
      <ul>
        <li>Reduce price gap or <code>compIntensity</code> to soften competition effects.</li>
        <li>Test <code>buzzStrength</code> for upside vs variance trade-off.</li>
        <li>Lower <code>supplierMean/Vol</code> if possible.</li>
        <li>Tune <code>confDecay</code> to balance stability vs agility.</li>
      </ul>
    </li>
    <li>Lock a candidate setup ‚Üí re-run <b>Monte Carlo</b> to confirm it‚Äôs robust (higher mean and/or tighter band).</li>
    <li>Use <b>Round Analyzer</b> to explain outliers (price, marketing, supplier cost, trend).</li>
  </ol>

  <h4>7) What ‚Äúgood‚Äù looks like</h4>
  <p>
    Prefer settings that raise the Monte Carlo <b>mean</b> while not exploding the <b>œÉ</b>.  
    If means are similar, choose the tighter band (lower downside risk).
  </p>

  <h4>8) Limits</h4>
  <ul>
    <li>Reduced-form demand (two segments, linear effects, clamping).</li>
    <li>Competitor/trend are exogenous (no full strategic learning/equilibrium).</li>
    <li>Buzz & confidence are simplified feedbacks without lags/saturation.</li>
  </ul>
</details>

       
    </div>
  </div>

  <script>
    // ---------- Helpers ----------
    const clamp = (x, lo, hi) => Math.max(lo, Math.min(hi, x));
    const rand = (a,b) => Math.random()*(b-a)+a;
    const choice = arr => arr[Math.floor(Math.random()*arr.length)];
    const mean = arr => arr.reduce((a,b)=>a+b,0) / (arr.length || 1);
    const std = arr => {
      const m = mean(arr);
      const v = mean(arr.map(x => (x-m)*(x-m)));
      return Math.sqrt(v);
    };
    const quantile = (arr, q) => {
      const a = [...arr].sort((x,y)=>x-y);
      const idx = (a.length-1)*q;
      const lo = Math.floor(idx), hi = Math.ceil(idx);
      if (lo === hi) return a[lo];
      return a[lo] + (a[hi]-a[lo])*(idx-lo);
    };

    class Segment {
      constructor(name, priceSens, mktSens, base=0.3){
        this.name=name; this.priceSens=priceSens; this.mktSens=mktSens; this.base=base;
      }
      buyProb(price, effMkt, relPricePenalty, trend){
        const p = this.base + this.mktSens*effMkt - this.priceSens*relPricePenalty + trend;
        return clamp(p,0,1);
      }
    }

    // ---------- Simulation ----------
    function simulate(params){
      const {
        rounds, startPrice, startMkt,
        useCompetitor, compIntensity,
        useInfluencer, buzzStrength,
        useSupplier, supplierMean, supplierVol,
        useInvestor, confDecay,
        useTrend
      } = params;

      // Consumers
      const segA = new Segment("A (price-sensitive)", 0.05, 0.15, 0.25);
      const segB = new Segment("B (brand-loyal)",     0.02, 0.08,  0.35);
      const segments=[segA, segB];

      let price=startPrice, marketing=startMkt;
      let competitorPrice = startPrice + rand(-0.5,0.5);
      let investorConf = 1.0;
      let totalBuyersPrev = 0;

      const out = { price:[], marketing:[], profit:[], buyers:[], perSeg:[], compPrice:[], invConf:[], suppCost:[], trend:[] };

      const trendMap = { boom: +0.05, stable: 0.0, recession: -0.10 };
      const profitWindow=[];

      for(let t=1;t<=rounds;t++){
        const trendState = useTrend ? choice(["boom","stable","recession"]) : "stable";
        const trendEffect = trendMap[trendState];

        price = clamp(price + rand(-0.3,0.3), 1, 999);
        marketing = clamp(marketing + rand(-0.05,0.05), 0, 1);

        if(useCompetitor){
          competitorPrice = clamp(competitorPrice + rand(-0.25,0.25), 1, 999);
        }

        const effMarketing = useInfluencer ? clamp(marketing + buzzStrength*(totalBuyersPrev/200), 0, 2) : marketing;
        const supplierCost = useSupplier ? clamp(supplierMean + rand(-supplierVol, supplierVol), 0, 10) : 0;

        let total=0; const segRows=[];
        for(const seg of segments){
          const relPricePenalty = useCompetitor ? (price - competitorPrice)*(1 + compIntensity*10) : price;
          const prob = seg.buyProb(price, effMarketing, relPricePenalty, trendEffect);
          let buyers=0; for(let i=0;i<100;i++){ if(Math.random()<prob) buyers++; }
          segRows.push({ name:seg.name, prob, buyers });
          total += buyers;
        }

        const revenue = total * price;
        const mktCost = 50 * marketing;
        const profit = (revenue - mktCost) - (supplierCost * total);

        profitWindow.push(profit); if(profitWindow.length>5) profitWindow.shift();
        const avgProfit = mean(profitWindow);
        if(useInvestor && profit < avgProfit){
          investorConf = clamp(investorConf - confDecay, 0.6, 1.2);
          marketing = clamp(marketing * investorConf, 0, 1);
        } else {
          investorConf = clamp(investorConf + confDecay*0.3, 0.6, 1.2);
        }

        out.price.push(price); out.marketing.push(marketing); out.profit.push(profit);
        out.buyers.push(total); out.perSeg.push(segRows);
        out.compPrice.push(competitorPrice); out.invConf.push(investorConf);
        out.suppCost.push(supplierCost); out.trend.push(trendState);

        totalBuyersPrev = total;
      }
      return out;
    }

    // ---------- Globals ----------
    let mainChart, sensChart, diffChart, mcChart;
    let lastResult = null;
    let lastParams = null;

    // ---------- Rendering (main) ----------
    function renderChart(data, selectedIndex = null){
      const ctx = document.getElementById('chart').getContext('2d');
      const labels = data.profit.map((_,i)=>`Round ${i+1}`);
      const pointR = data.profit.map((_,i)=> (i===selectedIndex ? 6 : 2));
      const ds = [
        { label:"Profit", data:data.profit, yAxisID:'y', pointRadius: pointR },
        { label:"Total Buyers", data:data.buyers, yAxisID:'y1' },
      ];
      if(mainChart) mainChart.destroy();
      mainChart = new Chart(ctx,{
        type:'line',
        data:{ labels, datasets: ds },
        options:{
          responsive:true, interaction:{ mode:'index', intersect:false },
          plugins:{ legend:{ position:'top' } },
          scales:{
            y:{ title:{ display:true, text:'Profit' } },
            y1:{ position:'right', grid:{ drawOnChartArea:false }, title:{ display:true, text:'Total Buyers' } }
          }
        }
      });
    }

    function renderSummary(data){
      const tbody = document.querySelector('#summary tbody'); tbody.innerHTML='';
      const n = data.profit.length-1;
      const rows = [
        ['Round', (n+1)],
        ['Price', data.price[n].toFixed(2)],
        ['Competitor Price', data.compPrice[n].toFixed(2)],
        ['Marketing', data.marketing[n].toFixed(2)],
        ['Supplier Cost', data.suppCost[n].toFixed(2)],
        ['Investor Confidence', data.invConf[n].toFixed(2)],
        ['Market Trend', data.trend[n]],
        ['Total Buyers', data.buyers[n]],
        ['Profit', data.profit[n].toFixed(2)],
        ['Seg A: P(buy), buyers', `${data.perSeg[n][0].prob.toFixed(2)}, ${data.perSeg[n][0].buyers}/100`],
        ['Seg B: P(buy), buyers', `${data.perSeg[n][1].prob.toFixed(2)}, ${data.perSeg[n][1].buyers}/100`],
      ];
      for(const [k,v] of rows){
        const tr=document.createElement('tr'); tr.innerHTML=`<th>${k}</th><td>${v}</td>`; tbody.appendChild(tr);
      }
    }

    function collectParamsFromUI(){
      return {
        rounds: +document.getElementById('rounds').value,
        startPrice: +document.getElementById('startPrice').value,
        startMkt: +document.getElementById('startMkt').value,
        useCompetitor: document.getElementById('useCompetitor').checked,
        compIntensity: +document.getElementById('compIntensity').value,
        useInfluencer: document.getElementById('useInfluencer').checked,
        buzzStrength: +document.getElementById('buzzStrength').value,
        useSupplier: document.getElementById('useSupplier').checked,
        supplierMean: +document.getElementById('supplierMean').value,
        supplierVol: +document.getElementById('supplierVol').value,
        useInvestor: document.getElementById('useInvestor').checked,
        confDecay: +document.getElementById('confDecay').value,
        useTrend: document.getElementById('useTrend').checked,
      };
    }

    function populateRoundSelector(nRounds){
      const sel = document.getElementById('roundSelect');
      sel.innerHTML = '';
      for(let i=1;i<=nRounds;i++){
        const opt = document.createElement('option');
        opt.value = i-1; // zero-based index
        opt.textContent = `Round ${i}`;
        sel.appendChild(opt);
      }
    }

    function runSim(){
      const params = collectParamsFromUI();
      const result = simulate(params);
      lastResult = result; lastParams = params;
      renderChart(result, null);
      renderSummary(result);
      populateRoundSelector(result.profit.length);
      if(diffChart){ diffChart.destroy(); diffChart=null; }
    }

    // ---------- Round Analyzer ----------
    function analyzeSelectedRound(){
      if(!lastResult) return;
      const baseIdx = +document.getElementById('roundSelect').value;
      const pr = lastResult.profit, brs = lastResult.buyers;
      const diffProfit = pr.map((v)=> v - pr[baseIdx]);
      const diffBuyers = brs.map((v)=> v - brs[baseIdx]);
      renderChart(lastResult, baseIdx);
      const ctx = document.getElementById('diffChart').getContext('2d');
      const labels = pr.map((_,i)=>`R${i+1}`);
      if(diffChart) diffChart.destroy();
      diffChart = new Chart(ctx, {
        type:'bar',
        data:{
          labels,
          datasets:[
            { label:`Œî Profit vs R${baseIdx+1}`, data: diffProfit },
            { label:`Œî Buyers vs R${baseIdx+1}`, data: diffBuyers }
          ]
        },
        options:{
          responsive:true,
          plugins:{ legend:{ position:'top' } },
          scales:{ y:{ title:{ display:true, text:'Difference' } } }
        }
      });
    }

    // ---------- Monte Carlo (NEW) ----------
    function runMonteCarlo(){
      const R = Math.max(5, Math.min(500, +document.getElementById('mcRuns').value || 60));
      const base = collectParamsFromUI();
      const rounds = base.rounds;

      // accumulate per-round sums and sums of squares
      const sum = Array(rounds).fill(0);
      const sumsq = Array(rounds).fill(0);
      const perRunAvg = []; // average profit per run

      for(let r=0; r<R; r++){
        const res = simulate(base);
        const avgP = mean(res.profit);
        perRunAvg.push(avgP);
        for(let i=0;i<rounds;i++){
          const p = res.profit[i];
          sum[i] += p; sumsq[i] += p*p;
        }
      }

      const meanPerRound = sum.map(v => v / R);
      const stdPerRound  = sumsq.map((v,i) => Math.sqrt(Math.max(0, v/R - meanPerRound[i]*meanPerRound[i])));

      // Overall stats on "average profit per run"
      const mcMean = mean(perRunAvg);
      const mcStd  = std(perRunAvg);
      const mcP05  = quantile(perRunAvg, 0.05);
      const mcP95  = quantile(perRunAvg, 0.95);

      // update tiles
      document.getElementById('mcMean').textContent = mcMean.toFixed(2);
      document.getElementById('mcStd').textContent  = mcStd.toFixed(2);
      document.getElementById('mcP05').textContent  = mcP05.toFixed(2);
      document.getElementById('mcP95').textContent  = mcP95.toFixed(2);

      // render mean ¬±1œÉ band chart
      const upper = meanPerRound.map((m,i)=> m + stdPerRound[i]);
      const lower = meanPerRound.map((m,i)=> m - stdPerRound[i]);
      const labels = meanPerRound.map((_,i)=>`Round ${i+1}`);

      const ctx = document.getElementById('mcChart').getContext('2d');
      if(mcChart) mcChart.destroy();

      // trick: draw lower first, then upper filled to previous, then mean line on top
      mcChart = new Chart(ctx, {
        type:'line',
        data:{
          labels,
          datasets:[
            {
              label:'-1œÉ',
              data: lower,
              borderColor: 'rgba(0,0,0,0)',
              backgroundColor: 'rgba(37, 99, 235, 0.10)', // fill color
            },
            {
              label:'+1œÉ',
              data: upper,
              borderColor: 'rgba(0,0,0,0)',
              backgroundColor: 'rgba(37, 99, 235, 0.10)',
              fill: '-1' // fill to the previous dataset (lower)
            },
            {
              label:'Mean Profit (per round)',
              data: meanPerRound,
              borderColor: '#2563eb',
              pointRadius: 2,
            }
          ]
        },
        options:{
          responsive:true,
          interaction:{ mode:'index', intersect:false },
          plugins:{ legend:{ position:'top' } },
          scales:{ y:{ title:{ display:true, text:'Profit' } } }
        }
      });
    }

    // ---------- Sensitivity Analysis (kept) ----------
    function simulateAvgProfit(params, repeats=20){
      const profits = [];
      for(let i=0;i<repeats;i++){
        const r = simulate(params);
        profits.push( mean(r.profit) );
      }
      return mean(profits);
    }

    function runSensitivity(){
      const base = collectParamsFromUI();
      const compVals = [0.00, 0.04, 0.08];
      const buzzVals = [0.00, 0.15, 0.30];
      const suppMeanVals = [0.6, 1.0, 1.4];
      const invDecayVals = [0.00, 0.05, 0.10];
      const trendVals = [false, true];

      const labels = [];
      const values = [];

      compVals.forEach(v=>{
        const p = { ...base, useCompetitor:true, compIntensity:v };
        labels.push(`Competitor ${v.toFixed(2)}`);
        values.push( simulateAvgProfit(p, 20) );
      });

      buzzVals.forEach(v=>{
        const p = { ...base, useInfluencer:true, buzzStrength:v };
        labels.push(`Influencer ${v.toFixed(2)}`);
        values.push( simulateAvgProfit(p, 20) );
      });

      suppMeanVals.forEach(v=>{
        const p = { ...base, useSupplier:true, supplierMean:v };
        labels.push(`Supplier Mean ${v.toFixed(1)}`);
        values.push( simulateAvgProfit(p, 20) );
      });

      invDecayVals.forEach(v=>{
        const p = { ...base, useInvestor:true, confDecay:v };
        labels.push(`Investor Decay ${v.toFixed(2)}`);
        values.push( simulateAvgProfit(p, 20) );
      });

      trendVals.forEach(v=>{
        const p = { ...base, useTrend:v };
        labels.push(`Trend ${v ? 'On' : 'Off'}`);
        values.push( simulateAvgProfit(p, 20) );
      });

      const ctx = document.getElementById('sensChart').getContext('2d');
      if(sensChart) sensChart.destroy();
      sensChart = new Chart(ctx, {
        type:'bar',
        data:{ labels, datasets:[{ label:'Average Profit (across rounds & runs)', data: values }] },
        options:{
          responsive:true,
          plugins:{ legend:{ display:true, position:'top' } },
          scales:{
            y:{ title:{ display:true, text:'Average Profit' } },
            x:{ ticks:{ maxRotation: 70, minRotation: 0 } }
          }
        }
      });
    }

    // auto-run on load
    window.addEventListener('DOMContentLoaded', runSim);
  </script>
</body>
</html>

<section id="project">
  <h3>üß≠ Development Progress</h3>
  <p>Follow updates and new features of the Sequential Consumer Game on GitHub:</p>
  <a href="https://github.com/users/ozhao8509-cyber/projects"
     target="_blank"
     style="color:#0078d4; text-decoration:none; font-weight:bold;">
     üîó View Project Board ‚Üí
  </a>
</section>






  <footer>
    <small>¬© 2025 Oscar Zhao</small>
  </footer>
</body>
</html>





<meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Oscar‚Äôs Website</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header>
    <h1>Hello, I‚Äôm Oscar üëã</h1>
    <p>Welcome to my personal website!</p>
  </header>

  <main>
    <section>
      <h2>About Me</h2>
      <p>I study empirical economics at Waseda University. I love data, policy, and creative research.</p>
    </section>

    <section>
      <h2>Projects</h2>
      <ul>
        <li>Public Space Friendliness Study (Tokyo)</li>
        <li>ESG Investment & Governance Analysis</li>
        <li>Comparative Political Economy Essay</li>
      </ul>
    </section>

    <section>
      <h2>Sequential Consumer Game</h2>
      <p>
        I built a chess-like Python simulation that pits a retailer against
        multiple consumer segments. Each turn the retailer makes the opening move
        (adjusting price and marketing), then the consumer "pieces" respond in
        sequence with probabilistic purchases and loyalty shifts.
      </p>
      <p>
        The script narrates the rules, plays through the turns, and prints a
        score table showing revenue, cost, and profit so you can interpret the
        strategic flow.
      </p>
      <ol>
        <li>Open the repository on GitHub and start a Codespace or the web editor.</li>
        <li>In the integrated terminal, run <code>python consumer_game.py</code>
          (or <code>python3 consumer_game.py</code>).</li>
        <li>Watch the narrated turns and tweak the segment profiles or strategy to
          explore new openings.</li>
      </ol>
      <p class="note">
        Any Python 3.8+ runtime works locally or on GitHub; the demo requires no
        additional packages.
      </p>
    </section>

    <section>
      <h2>Contact</h2>
      <p>Email: ozhao8509@email.com</p>
    </section>
  </main>
      <a href="china-ngo-localization-20251022.pptx" class="btn" download>üìÇ View Presentation</a>
  <!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sequential Consumer Game (Browser Version)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>

  <style>
    :root{
      --bg:#f7f7f7; --ink:#111827; --muted:#6b7280; --card:#ffffff; --line:#e5e7eb;
      --accent:#2563eb; --accent-2:#0ea5e9;
    }
    body{ margin:0; background:var(--bg); color:var(--ink); font:16px/1.45 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial; }
    .wrap{ max-width: 980px; margin: 32px auto; padding: 0 16px; }
    h1{ font-size: 32px; margin: 0 0 10px; }
    p.muted{ color:var(--muted); margin-top:6px; }
    .panel{ display:grid; grid-template-columns: 1.1fr .9fr; gap: 16px; margin: 18px 0; }
    .card{
      background:var(--card); color:var(--ink); padding:16px; border-radius:14px;
      box-shadow:0 8px 24px rgba(0,0,0,.08); border:1px solid var(--line);
    }
    label{ display:block; font-size:14px; margin:10px 0 4px; }
    input[type="range"]{ width:100%; }
    input[type="number"], select{ padding:6px 8px; border:1px solid var(--line); border-radius:8px;}
    .row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .row > div{ display:flex; align-items:center; gap:8px; }
    .switch{ display:flex; align-items:center; gap:8px; margin-top:8px; }
    button{
      background:var(--accent); color:#fff; border:0; padding:10px 14px; border-radius:10px;
      cursor:pointer;
    }
    button.secondary{ background:var(--accent-2); }
    button:hover{ filter:brightness(1.07); }

    table{ width:100%; border-collapse:collapse; margin-top:6px; }
    th,td{ padding:8px 10px; border-bottom:1px solid var(--line); text-align:left; }
    th{ font-weight:600; }

    #chartWrap, #sensWrap, #diffWrap, #mcWrap, #dynWrap1, #dynWrap2{
      background:var(--card); border:1px solid var(--line); border-radius:14px; padding:12px;
    }

    @media (max-width: 900px){ .panel{ grid-template-columns: 1fr; } }
    .stat{ display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:10px; }
    .stat .tile{ background:#fafafa; border:1px solid var(--line); border-radius:10px; padding:10px; }
    .stat .k{ font-size:12px; color:var(--muted); }
    .stat .v{ font-weight:600; font-size:18px; }

    details summary{ cursor:pointer; }
    details pre{ background:#fafafa; border:1px solid var(--line); padding:10px; border-radius:10px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Sequential Consumer Game (Browser Version)</h1>
    <p class="muted">Adjust rounds, price, and marketing; includes competitor, influencer, supplier, investor, and market trend roles. Everything runs client-side on GitHub Pages.</p>

    <!-- Controls + Last Round Summary -->
    <div class="panel">
      <div class="card">
        <div class="row">
          <div style="flex:1">
            <label>Rounds: <span id="roundsVal">20</span></label>
            <input id="rounds" type="range" min="5" max="100" value="20" oninput="roundsVal.textContent=this.value">
          </div>
          <div style="flex:1">
            <label>Start Price: <span id="priceVal">9.5</span></label>
            <input id="startPrice" type="range" min="3" max="25" step="0.1" value="9.5" oninput="priceVal.textContent=this.value">
          </div>
        </div>

        <div class="row">
          <div style="flex:1">
            <label>Start Marketing: <span id="mktVal">0.60</span></label>
            <input id="startMkt" type="range" min="0" max="1" step="0.01" value="0.60" oninput="mktVal.textContent=this.value">
          </div>
          <div class="row">
            <button onclick="runSim()">Run Simulation</button>
          </div>
        </div>

        <hr style="border:none;border-top:1px solid var(--line);margin:14px 0">

        <!-- Role toggles -->
        <div class="row">
          <div class="switch">
            <input type="checkbox" id="useCompetitor" checked>
            <label for="useCompetitor">Competitor (price competition)</label>
          </div>
          <div>
            <label>Competitor Intensity</label>
            <input id="compIntensity" type="range" min="0" max="0.08" step="0.005" value="0.04">
          </div>
        </div>

        <div class="row">
          <div class="switch">
            <input type="checkbox" id="useInfluencer" checked>
            <label for="useInfluencer">Influencer buzz</label>
          </div>
          <div>
            <label>Buzz Strength</label>
            <input id="buzzStrength" type="range" min="0" max="0.3" step="0.01" value="0.15">
          </div>
        </div>

        <div class="row">
          <div class="switch">
            <input type="checkbox" id="useSupplier" checked>
            <label for="useSupplier">Supplier cost</label>
          </div>
          <div>
            <label>Mean Cost</label>
            <input id="supplierMean" type="number" step="0.1" value="1.0">
          </div>
          <div>
            <label>Volatility</label>
            <input id="supplierVol" type="number" step="0.05" value="0.2">
          </div>
        </div>

        <div class="row">
          <div class="switch">
            <input type="checkbox" id="useInvestor" checked>
            <label for="useInvestor">Investor confidence feedback</label>
          </div>
          <div>
            <label>Confidence decay</label>
            <input id="confDecay" type="range" min="0" max="0.2" step="0.01" value="0.05">
          </div>
        </div>

        <div class="row">
          <div class="switch">
            <input type="checkbox" id="useTrend" checked>
            <label for="useTrend">Market trend shocks</label>
          </div>
        </div>
      </div>

      <div class="card">
        <b>Last Round Summary</b>
        <table id="summary">
          <thead><tr><th>Metric</th><th>Value</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <!-- Main Chart -->
    <div id="chartWrap"><canvas id="chart" height="140"></canvas></div>

    <!-- NEW: Shocks & Costs dynamics -->
    <div class="card" style="margin-top:14px">
      <div class="row" style="justify-content:space-between;">
        <div><b>Market Trend Shocks & Supplier Costs</b></div>
        <div class="muted">Shows how macro trend (boom/stable/recession) and supplier cost fluctuate across rounds.</div>
      </div>
      <div id="dynWrap1" style="margin-top:10px">
        <canvas id="dynChart1" height="120"></canvas>
      </div>
    </div>

    <!-- NEW: Feedback dynamics -->
    <div class="card" style="margin-top:14px">
      <div class="row" style="justify-content:space-between;">
        <div><b>Investor Confidence & Influencer Buzz</b></div>
        <div class="muted">Tracks investor confidence, base marketing, effective marketing, and buzz contribution per round.</div>
      </div>
      <div id="dynWrap2" style="margin-top:10px">
        <canvas id="dynChart2" height="120"></canvas>
      </div>
    </div>

    <!-- Monte Carlo Averaging -->
    <div class="card" style="margin-top:14px">
      <div class="row" style="justify-content:space-between;">
        <div><b>Monte Carlo Averaging (reduce randomness)</b></div>
        <div class="muted">Runs multiple simulations with current settings; shows mean profit per round and ¬±1œÉ band.</div>
      </div>
      <div class="row" style="margin-top:10px">
        <div>
          <label>Runs (R)</label>
          <input id="mcRuns" type="number" min="5" max="500" step="5" value="60">
        </div>
        <button class="secondary" onclick="runMonteCarlo()">Run Monte Carlo</button>
      </div>

      <div class="stat" style="margin-top:10px">
        <div class="tile"><div class="k">Mean of Avg Profit</div><div class="v" id="mcMean">‚Äî</div></div>
        <div class="tile"><div class="k">Std of Avg Profit</div><div class="v" id="mcStd">‚Äî</div></div>
        <div class="tile"><div class="k">5th Percentile</div><div class="v" id="mcP05">‚Äî</div></div>
        <div class="tile"><div class="k">95th Percentile</div><div class="v" id="mcP95">‚Äî</div></div>
      </div>

      <div id="mcWrap" style="margin-top:10px">
        <canvas id="mcChart" height="140"></canvas>
      </div>
    </div>

    <!-- Round Analyzer -->
    <div class="card" style="margin-top:14px">
      <div class="row" style="justify-content:space-between;">
        <div><b>Round Analyzer</b></div>
        <div class="muted">Choose a round as the baseline; we compute differences to all other rounds and highlight it.</div>
      </div>
      <div class="row" style="margin-top:10px">
        <div>
          <label for="roundSelect">Select round</label>
          <select id="roundSelect"></select>
        </div>
        <button onclick="analyzeSelectedRound()">Analyze Round</button>
      </div>
      <div id="diffWrap" style="margin-top:10px">
        <canvas id="diffChart" height="140"></canvas>
      </div>
    </div>

    <!-- Sensitivity Analysis -->
    <div class="card" style="margin-top:14px">
      <div class="row" style="justify-content:space-between;">
        <div><b>Sensitivity Analysis</b></div>
        <div class="muted">Varies key role parameters (low/mid/high), averages 20 runs per scenario, and compares average profit.</div>
      </div>
      <div class="row" style="margin-top:10px">
        <button onclick="runSensitivity()">Run Sensitivity</button>
      </div>
      <div id="sensWrap" style="margin-top:10px"><canvas id="sensChart" height="140"></canvas></div>
    </div>

    <!-- About the model (you can later replace this with the longer detailed version if you like) -->
    <div class="card" style="margin-top:14px">
      <details>
        <summary><b>About the model</b></summary>
        <p class="muted">
          Demand per segment: <code>P(buy)=base + mktSens*effectiveMarketing - priceSens*(price - competitorPriceAdj) + trendEffect</code>. 
          Profit: <code>(price - supplierCost) * totalBuyers - 50*marketing</code>. Investor confidence reduces marketing when profit is below recent average.
        </p>
      </details>
    </div>
  </div>

  <script>
    // ---------- Helpers ----------
    const clamp = (x, lo, hi) => Math.max(lo, Math.min(hi, x));
    const rand = (a,b) => Math.random()*(b-a)+a;
    const choice = arr => arr[Math.floor(Math.random()*arr.length)];
    const mean = arr => arr.reduce((a,b)=>a+b,0) / (arr.length || 1);
    const std = arr => {
      const m = mean(arr);
      const v = mean(arr.map(x => (x-m)*(x-m)));
      return Math.sqrt(v);
    };
    const quantile = (arr, q) => {
      const a = [...arr].sort((x,y)=>x-y);
      const idx = (a.length-1)*q;
      const lo = Math.floor(idx), hi = Math.ceil(idx);
      if (lo === hi) return a[lo];
      return a[lo] + (a[hi]-a[lo])*(idx-lo);
    };

    class Segment {
      constructor(name, priceSens, mktSens, base=0.3){
        this.name=name; this.priceSens=priceSens; this.mktSens=mktSens; this.base=base;
      }
      buyProb(price, effMkt, relPricePenalty, trend){
        const p = this.base + this.mktSens*effMkt - this.priceSens*relPricePenalty + trend;
        return clamp(p,0,1);
      }
    }

    // ---------- Simulation ----------
    function simulate(params){
      const {
        rounds, startPrice, startMkt,
        useCompetitor, compIntensity,
        useInfluencer, buzzStrength,
        useSupplier, supplierMean, supplierVol,
        useInvestor, confDecay,
        useTrend
      } = params;

      // Consumers
      const segA = new Segment("A (price-sensitive)", 0.05, 0.15, 0.25);
      const segB = new Segment("B (brand-loyal)",     0.02, 0.08,  0.35);
      const segments=[segA, segB];

      let price=startPrice, marketing=startMkt;
      let competitorPrice = startPrice + rand(-0.5,0.5);
      let investorConf = 1.0;
      let totalBuyersPrev = 0;

      const out = {
        price:[], marketing:[], profit:[], buyers:[], perSeg:[],
        compPrice:[], invConf:[], suppCost:[], trend:[],
        effMkt:[], buzz:[], trendEffect:[]
      };

      const trendMap = { boom: +0.05, stable: 0.0, recession: -0.10 };
      const profitWindow=[];

      for(let t=1;t<=rounds;t++){
        // Trend state
        const trendState = useTrend ? choice(["boom","stable","recession"]) : "stable";
        const trendEffect = trendMap[trendState];

        // Random walk for price & marketing
        price = clamp(price + rand(-0.3,0.3), 1, 999);
        marketing = clamp(marketing + rand(-0.05,0.05), 0, 1);

        // Competitor price
        if(useCompetitor){
          competitorPrice = clamp(competitorPrice + rand(-0.25,0.25), 1, 999);
        }

        // Influencer buzz & effective marketing
        let buzzTerm = 0;
        let effMarketing;
        if(useInfluencer){
          buzzTerm = buzzStrength * (totalBuyersPrev / 200);
          effMarketing = clamp(marketing + buzzTerm, 0, 2);
        } else {
          effMarketing = marketing;
        }

        // Supplier cost
        const supplierCost = useSupplier
          ? clamp(supplierMean + rand(-supplierVol, supplierVol), 0, 10)
          : 0;

        // Demand per segment
        let total=0; const segRows=[];
        for(const seg of segments){
          const relPricePenalty = useCompetitor
            ? (price - competitorPrice)*(1 + compIntensity*10)
            : price;
          const prob = seg.buyProb(price, effMarketing, relPricePenalty, trendEffect);
          let buyers=0; for(let i=0;i<100;i++){ if(Math.random()<prob) buyers++; }
          segRows.push({ name:seg.name, prob, buyers });
          total += buyers;
        }

        const revenue = total * price;
        const mktCost = 50 * marketing;
        const profit = (revenue - mktCost) - (supplierCost * total);

        // Investor confidence update
        profitWindow.push(profit); if(profitWindow.length>5) profitWindow.shift();
        const avgProfit = mean(profitWindow);
        if(useInvestor && profit < avgProfit){
          investorConf = clamp(investorConf - confDecay, 0.6, 1.2);
          marketing = clamp(marketing * investorConf, 0, 1);
        } else {
          investorConf = clamp(investorConf + confDecay*0.3, 0.6, 1.2);
        }

        // Store everything
        out.price.push(price);
        out.marketing.push(marketing);
        out.profit.push(profit);
        out.buyers.push(total);
        out.perSeg.push(segRows);
        out.compPrice.push(competitorPrice);
        out.invConf.push(investorConf);
        out.suppCost.push(supplierCost);
        out.trend.push(trendState);
        out.effMkt.push(effMarketing);
        out.buzz.push(buzzTerm);
        out.trendEffect.push(trendEffect);

        totalBuyersPrev = total;
      }
      return out;
    }

    // ---------- Globals ----------
    let mainChart, sensChart, diffChart, mcChart, dynChart1, dynChart2;
    let lastResult = null;
    let lastParams = null;

    // ---------- Rendering (main profit/buyers) ----------
    function renderChart(data, selectedIndex = null){
      const ctx = document.getElementById('chart').getContext('2d');
      const labels = data.profit.map((_,i)=>`Round ${i+1}`);
      const pointR = data.profit.map((_,i)=> (i===selectedIndex ? 6 : 2));
      const ds = [
        { label:"Profit", data:data.profit, yAxisID:'y', pointRadius: pointR },
        { label:"Total Buyers", data:data.buyers, yAxisID:'y1' },
      ];
      if(mainChart) mainChart.destroy();
      mainChart = new Chart(ctx,{
        type:'line',
        data:{ labels, datasets: ds },
        options:{
          responsive:true, interaction:{ mode:'index', intersect:false },
          plugins:{ legend:{ position:'top' } },
          scales:{
            y:{ title:{ display:true, text:'Profit' } },
            y1:{ position:'right', grid:{ drawOnChartArea:false }, title:{ display:true, text:'Total Buyers' } }
          }
        }
      });
    }

    function renderSummary(data){
      const tbody = document.querySelector('#summary tbody'); tbody.innerHTML='';
      const n = data.profit.length-1;
      const rows = [
        ['Round', (n+1)],
        ['Price', data.price[n].toFixed(2)],
        ['Competitor Price', data.compPrice[n].toFixed(2)],
        ['Marketing', data.marketing[n].toFixed(2)],
        ['Effective Marketing', data.effMkt[n].toFixed(2)],
        ['Buzz Contribution', data.buzz[n].toFixed(3)],
        ['Supplier Cost', data.suppCost[n].toFixed(2)],
        ['Investor Confidence', data.invConf[n].toFixed(2)],
        ['Market Trend', data.trend[n]],
        ['Total Buyers', data.buyers[n]],
        ['Profit', data.profit[n].toFixed(2)],
        ['Seg A: P(buy), buyers', `${data.perSeg[n][0].prob.toFixed(2)}, ${data.perSeg[n][0].buyers}/100`],
        ['Seg B: P(buy), buyers', `${data.perSeg[n][1].prob.toFixed(2)}, ${data.perSeg[n][1].buyers}/100`],
      ];
      for(const [k,v] of rows){
        const tr=document.createElement('tr'); tr.innerHTML=`<th>${k}</th><td>${v}</td>`; tbody.appendChild(tr);
      }
    }

    function collectParamsFromUI(){
      return {
        rounds: +document.getElementById('rounds').value,
        startPrice: +document.getElementById('startPrice').value,
        startMkt: +document.getElementById('startMkt').value,
        useCompetitor: document.getElementById('useCompetitor').checked,
        compIntensity: +document.getElementById('compIntensity').value,
        useInfluencer: document.getElementById('useInfluencer').checked,
        buzzStrength: +document.getElementById('buzzStrength').value,
        useSupplier: document.getElementById('useSupplier').checked,
        supplierMean: +document.getElementById('supplierMean').value,
        supplierVol: +document.getElementById('supplierVol').value,
        useInvestor: document.getElementById('useInvestor').checked,
        confDecay: +document.getElementById('confDecay').value,
        useTrend: document.getElementById('useTrend').checked,
      };
    }

    function populateRoundSelector(nRounds){
      const sel = document.getElementById('roundSelect');
      sel.innerHTML = '';
      for(let i=1;i<=nRounds;i++){
        const opt = document.createElement('option');
        opt.value = i-1; // zero-based index
        opt.textContent = `Round ${i}`;
        sel.appendChild(opt);
      }
    }

    // ---------- NEW: render dynamics charts ----------
    function renderDynamics(data){
      const labels = data.profit.map((_,i)=>`Round ${i+1}`);

      // Chart 1: Supplier cost + Trend effect
      const ctx1 = document.getElementById('dynChart1').getContext('2d');
      if(dynChart1) dynChart1.destroy();
      dynChart1 = new Chart(ctx1, {
        type:'line',
        data:{
          labels,
          datasets:[
            { label:'Supplier Cost', data:data.suppCost, yAxisID:'y' },
            { label:'Trend Effect (boom/stable/recession)', data:data.trendEffect, yAxisID:'y1' }
          ]
        },
        options:{
          responsive:true,
          interaction:{ mode:'index', intersect:false },
          plugins:{ legend:{ position:'top' } },
          scales:{
            y:{ title:{ display:true, text:'Supplier Cost' } },
            y1:{ position:'right', grid:{ drawOnChartArea:false }, title:{ display:true, text:'Trend Effect' } }
          }
        }
      });

      // Chart 2: Investor confidence + marketing + effective marketing + buzz
      const ctx2 = document.getElementById('dynChart2').getContext('2d');
      if(dynChart2) dynChart2.destroy();
      dynChart2 = new Chart(ctx2, {
        type:'line',
        data:{
          labels,
          datasets:[
            { label:'Investor Confidence', data:data.invConf },
            { label:'Base Marketing', data:data.marketing },
            { label:'Effective Marketing', data:data.effMkt },
            { label:'Buzz Contribution', data:data.buzz }
          ]
        },
        options:{
          responsive:true,
          interaction:{ mode:'index', intersect:false },
          plugins:{ legend:{ position:'top' } },
          scales:{
            y:{ title:{ display:true, text:'Level' } }
          }
        }
      });
    }

    function runSim(){
      const params = collectParamsFromUI();
      const result = simulate(params);
      lastResult = result; lastParams = params;
      renderChart(result, null);
      renderSummary(result);
      renderDynamics(result);
      populateRoundSelector(result.profit.length);
      if(diffChart){ diffChart.destroy(); diffChart=null; }
    }

    // ---------- Round Analyzer ----------
    function analyzeSelectedRound(){
      if(!lastResult) return;
      const baseIdx = +document.getElementById('roundSelect').value;
      const pr = lastResult.profit, brs = lastResult.buyers;
      const diffProfit = pr.map((v)=> v - pr[baseIdx]);
      const diffBuyers = brs.map((v)=> v - brs[baseIdx]);
      renderChart(lastResult, baseIdx);
      const ctx = document.getElementById('diffChart').getContext('2d');
      const labels = pr.map((_,i)=>`R${i+1}`);
      if(diffChart) diffChart.destroy();
      diffChart = new Chart(ctx, {
        type:'bar',
        data:{
          labels,
          datasets:[
            { label:`Œî Profit vs R${baseIdx+1}`, data: diffProfit },
            { label:`Œî Buyers vs R${baseIdx+1}`, data: diffBuyers }
          ]
        },
        options:{
          responsive:true,
          plugins:{ legend:{ position:'top' } },
          scales:{ y:{ title:{ display:true, text:'Difference' } } }
        }
      });
    }

    // ---------- Monte Carlo ----------
    function runMonteCarlo(){
      const R = Math.max(5, Math.min(500, +document.getElementById('mcRuns').value || 60));
      const base = collectParamsFromUI();
      const rounds = base.rounds;

      const sum = Array(rounds).fill(0);
      const sumsq = Array(rounds).fill(0);
      const perRunAvg = [];

      for(let r=0; r<R; r++){
        const res = simulate(base);
        const avgP = mean(res.profit);
        perRunAvg.push(avgP);
        for(let i=0;i<rounds;i++){
          const p = res.profit[i];
          sum[i] += p; sumsq[i] += p*p;
        }
      }

      const meanPerRound = sum.map(v => v / R);
      const stdPerRound  = sumsq.map((v,i) => Math.sqrt(Math.max(0, v/R - meanPerRound[i]*meanPerRound[i])));

      const mcMean = mean(perRunAvg);
      const mcStd  = std(perRunAvg);
      const mcP05  = quantile(perRunAvg, 0.05);
      const mcP95  = quantile(perRunAvg, 0.95);

      document.getElementById('mcMean').textContent = mcMean.toFixed(2);
      document.getElementById('mcStd').textContent  = mcStd.toFixed(2);
      document.getElementById('mcP05').textContent  = mcP05.toFixed(2);
      document.getElementById('mcP95').textContent  = mcP95.toFixed(2);

      const upper = meanPerRound.map((m,i)=> m + stdPerRound[i]);
      const lower = meanPerRound.map((m,i)=> m - stdPerRound[i]);
      const labels = meanPerRound.map((_,i)=>`Round ${i+1}`);

      const ctx = document.getElementById('mcChart').getContext('2d');
      if(mcChart) mcChart.destroy();

      mcChart = new Chart(ctx, {
        type:'line',
        data:{
          labels,
          datasets:[
            {
              label:'-1œÉ',
              data: lower,
              borderColor: 'rgba(0,0,0,0)',
              backgroundColor: 'rgba(37, 99, 235, 0.10)',
            },
            {
              label:'+1œÉ',
              data: upper,
              borderColor: 'rgba(0,0,0,0)',
              backgroundColor: 'rgba(37, 99, 235, 0.10)',
              fill: '-1'
            },
            {
              label:'Mean Profit (per round)',
              data: meanPerRound,
              borderColor: '#2563eb',
              pointRadius: 2,
            }
          ]
        },
        options:{
          responsive:true,
          interaction:{ mode:'index', intersect:false },
          plugins:{ legend:{ position:'top' } },
          scales:{ y:{ title:{ display:true, text:'Profit' } } }
        }
      });
    }

    // ---------- Sensitivity Analysis ----------
    function simulateAvgProfit(params, repeats=20){
      const profits = [];
      for(let i=0;i<repeats;i++){
        const r = simulate(params);
        profits.push( mean(r.profit) );
      }
      return mean(profits);
    }

    function runSensitivity(){
      const base = collectParamsFromUI();
      const compVals = [0.00, 0.04, 0.08];
      const buzzVals = [0.00, 0.15, 0.30];
      const suppMeanVals = [0.6, 1.0, 1.4];
      const invDecayVals = [0.00, 0.05, 0.10];
      const trendVals = [false, true];

      const labels = [];
      const values = [];

      compVals.forEach(v=>{
        const p = { ...base, useCompetitor:true, compIntensity:v };
        labels.push(`Competitor ${v.toFixed(2)}`);
        values.push( simulateAvgProfit(p, 20) );
      });

      buzzVals.forEach(v=>{
        const p = { ...base, useInfluencer:true, buzzStrength:v };
        labels.push(`Influencer ${v.toFixed(2)}`);
        values.push( simulateAvgProfit(p, 20) );
      });

      suppMeanVals.forEach(v=>{
        const p = { ...base, useSupplier:true, supplierMean:v };
        labels.push(`Supplier Mean ${v.toFixed(1)}`);
        values.push( simulateAvgProfit(p, 20) );
      });

      invDecayVals.forEach(v=>{
        const p = { ...base, useInvestor:true, confDecay:v };
        labels.push(`Investor Decay ${v.toFixed(2)}`);
        values.push( simulateAvgProfit(p, 20) );
      });

      trendVals.forEach(v=>{
        const p = { ...base, useTrend:v };
        labels.push(`Trend ${v ? 'On' : 'Off'}`);
        values.push( simulateAvgProfit(p, 20) );
      });

      const ctx = document.getElementById('sensChart').getContext('2d');
      if(sensChart) sensChart.destroy();
      sensChart = new Chart(ctx, {
        type:'bar',
        data:{ labels, datasets:[{ label:'Average Profit (across rounds & runs)', data: values }] },
        options:{
          responsive:true,
          plugins:{ legend:{ display:true, position:'top' } },
          scales:{
            y:{ title:{ display:true, text:'Average Profit' } },
            x:{ ticks:{ maxRotation: 70, minRotation: 0 } }
          }
        }
      });
    }

    // auto-run on load
    window.addEventListener('DOMContentLoaded', runSim);
  </script>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Game Logic Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true, theme: 'base', themeVariables: { fontFamily: 'ui-sans-serif' } });
  </script>

  <style>
    :root{
      --bg:#f7f7f7; --ink:#111827; --muted:#6b7280; --card:#ffffff; --line:#e5e7eb;
      --accent:#2563eb; --accent-light:#dbeafe; --success:#10b981; --danger:#ef4444; --warn:#f59e0b;
    }
    body{ margin:0; background:var(--bg); color:var(--ink); font-family: ui-sans-serif, system-ui, sans-serif; }
    .wrap{ max-width: 1000px; margin: 40px auto; padding: 0 20px; }
    
    h1{ font-size: 32px; margin-bottom: 8px; letter-spacing: -0.02em; }
    h2{ font-size: 22px; margin-top: 30px; border-bottom: 1px solid var(--line); padding-bottom: 10px; }
    p.intro{ color: var(--muted); font-size: 18px; margin-top:0; }
    
    /* Card Styling */
    .card{
      background:var(--card); padding:24px; border-radius:12px;
      box-shadow:0 4px 12px rgba(0,0,0,0.05); border:1px solid var(--line);
      margin-bottom: 24px;
    }

    /* Grid for Actor Cards */
    .grid-actors{ display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; margin-top: 20px; }
    .actor-card{
      border: 1px solid var(--line); border-radius: 8px; padding: 16px; background: #fafafa;
      border-left: 4px solid var(--accent);
    }
    .actor-card h3{ margin: 0 0 8px 0; font-size: 16px; display: flex; align-items: center; gap: 8px; }
    .actor-card p{ margin: 0; font-size: 14px; color: var(--muted); line-height: 1.5; }
    .tag{ font-size: 10px; text-transform: uppercase; padding: 2px 6px; border-radius: 4px; font-weight: 700; letter-spacing: 0.05em; }
    
    /* Specific colors for actors */
    .act-comp{ border-left-color: var(--danger); } .act-comp .tag{ background: #fee2e2; color: var(--danger); }
    .act-inf{ border-left-color: var(--accent); } .act-inf .tag{ background: var(--accent-light); color: var(--accent); }
    .act-inv{ border-left-color: var(--warn); } .act-inv .tag{ background: #fef3c7; color: var(--warn); }
    .act-sup{ border-left-color: var(--muted); } .act-sup .tag{ background: #f3f4f6; color: var(--muted); }

    /* Diagram Container */
    .diagram-container{
      display: flex; justify-content: center; background: #fff; 
      border-radius: 8px; overflow: hidden; padding: 20px 0;
    }
  </style>
</head>
<body>

<div class="wrap">

  <h1>Game Logic Explainer</h1>
  <p class="intro">A visual guide to understanding the connections in the Sequential Consumer Game.</p>

  <div class="card">
    <b>1. The Ecosystem Structure (Mindmap)</b>
    <p style="color:var(--muted); margin-bottom:20px">This map shows the four main pillars of your simulation: Inputs, External Forces, The Consumer Brain, and Analytics.</p>
    
    <div class="diagram-container">
      <pre class="mermaid">
mindmap
  root((Consumer Game))
    Inputs
      Start Price
      Start Marketing
      Rounds
    Market Forces
      Competitors
        (Price War)
      Influencers
        (Buzz Loop)
      Suppliers
        (Cost Volatility)
      Investors
        (Budget Control)
      Trends
        (Boom/Recession)
    Consumer Brain
      Segment A
        (Price Sensitive)
      Segment B
        (Brand Loyal)
    Analytics
      Main Chart
      Monte Carlo
      Sensitivity
      </pre>
    </div>
  </div>

  <h2>2. The Agents & Market Forces</h2>
  <p style="color:var(--muted)">Your game isn't static. These 5 agents actively change the variables every round.</p>
  
  <div class="grid-actors">
    <div class="actor-card act-comp">
      <h3>Competitor <span class="tag">Adversary</span></h3>
      <p><strong>Logic:</strong> They watch your price. If you go high, they undercut you.<br><br>
      <strong>Impact:</strong> Creates a "Price Penalty." If they are cheaper, price-sensitive buyers abandon you.</p>
    </div>

    <div class="actor-card act-inf">
      <h3>Influencer <span class="tag">Booster</span></h3>
      <p><strong>Logic:</strong> Triggered by previous sales. High sales yesterday = High Buzz today.<br><br>
      <strong>Impact:</strong> Adds a free bonus to your "Effective Marketing" stat.</p>
    </div>

    <div class="actor-card act-inv">
      <h3>Investor <span class="tag">Regulator</span></h3>
      <p><strong>Logic:</strong> Compares current profit to your average. If you underperform, they panic.<br><br>
      <strong>Impact:</strong> They force-cut your marketing budget, creating a "death spiral" risk.</p>
    </div>

    <div class="actor-card act-sup">
      <h3>Supplier <span class="tag">Volatility</span></h3>
      <p><strong>Logic:</strong> Randomly fluctuates the cost of goods sold (COGS).<br><br>
      <strong>Impact:</strong> Can ruin a high-sales round by eating up all the profit margin unexpectedly.</p>
    </div>

    <div class="actor-card" style="border-left-color:#10b981">
      <h3>Market Trend <span class="tag" style="background:#d1fae5;color:#10b981">Environment</span></h3>
      <p><strong>Logic:</strong> Randomly sets the world to Boom, Stable, or Recession.<br><br>
      <strong>Impact:</strong> A global modifier that increases or decreases buying probability for everyone.</p>
    </div>
  </div>

  <div class="card" style="margin-top:24px;">
    <b>3. The Logic Loop (Sequence of Events)</b>
    <p style="color:var(--muted); margin-bottom:20px">What actually happens inside the code when you click "Run"? This flowchart traces the data path for a single round.</p>

    <div class="diagram-container">
      <pre class="mermaid">
graph TD
    %% Nodes
    Start([Start Round])
    
    subgraph "1. World State"
    Trend{Market Trend?}
    Supp[Supplier Cost Set]
    Comp[Competitor Price Set]
    end

    subgraph "2. Your Position"
    Price[Your Price]
    Mkt[Marketing Budget]
    Buzz[Influencer Buzz]
    EffMkt[Effective Marketing]
    end

    subgraph "3. Consumer Decision"
    Math[Calculate Probability]
    SegA[Segment A: Price Focused]
    SegB[Segment B: Brand Focused]
    Buy[Total Sales]
    end

    subgraph "4. Feedback Loops"
    Profit[Calculate Profit]
    InvCheck{Profit < Average?}
    NextMkt[Investor Adjusts Next Budget]
    NextBuzz[Sales Fuel Next Buzz]
    end

    %% Connections
    Start --> Trend
    Trend --> Math
    Supp --> Profit
    Comp --> Math

    Mkt --> EffMkt
    Buzz --> EffMkt
    EffMkt --> Math
    Price --> Math
    
    Math --> SegA & SegB
    SegA & SegB --> Buy
    Buy --> Profit
    
    Profit --> InvCheck
    InvCheck -->|Yes| NextMkt
    Buy --> NextBuzz

    style Start fill:#f9f,stroke:#333
    style Profit fill:#dbeafe,stroke:#2563eb
    style Buy fill:#d1fae5,stroke:#10b981
      </pre>
    </div>
  </div>

  <div class="card">
    <b>4. The Consumer Math</b>
    <p style="color:var(--muted)">How does the code decide if a customer buys? It uses a scoring formula.</p>
    <div style="background:#f1f5f9; padding:15px; border-radius:8px; font-family:monospace; font-size:14px;">
      P(Buy) = Base_Desire <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (Marketing √ó Sensitivity)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- (Price_Difference √ó Sensitivity)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ Trend_Effect
    </div>
    <ul style="margin-top:15px; font-size:15px; line-height:1.6; color:var(--muted)">
      <li><strong>Segment A:</strong> High price sensitivity (0.05), Low marketing sensitivity.</li>
      <li><strong>Segment B:</strong> Low price sensitivity, High marketing sensitivity (0.08).</li>
      <li><strong>Result:</strong> The code rolls a digital dice (0 to 1) against this probability 100 times per segment.</li>
    </ul>
  </div>

</div>

</body>
</html>

  <h4>1) Core idea</h4>
  <p>
    A retailer chooses <i>price</i> and <i>marketing</i> each round. Two consumer segments (A: price-sensitive, B: brand-loyal) decide to buy.
    Optional roles‚ÄîCompetitor, Influencer Buzz, Supplier Cost, Investor Confidence, and Market Trend‚Äîmodify demand or costs.
  </p>

  <h4>2) Equations (per round)</h4>
  <pre style="white-space:pre-wrap">
Demand per segment:
  P(buy) = base + mktSens * effectiveMarketing ‚àí priceSens * (price ‚àí competitorAdj) + trendEffect
  0 ‚â§ P(buy) ‚â§ 1   (clamped)

Buyers per segment ‚âà Binomial(100, P(buy))   ‚Üí  TotalBuyers = buyers_A + buyers_B

Profit:
  Profit = (price ‚àí supplierCost) * TotalBuyers ‚àí 50 * marketing

Competitor adjustment (if enabled):
  competitorAdj = competitorPrice * (1 + compIntensity * 10)
  (Stronger intensity magnifies the penalty for pricing above the competitor.)

Influencer buzz (if enabled):
  effectiveMarketing = marketing + buzzStrength * (TotalBuyers(previous round) / 200)

Supplier cost (if enabled):
  supplierCost ~ mean(supplierMean) ¬± supplierVol   (clamped ‚â• 0)

Investor confidence (if enabled):
  If profit < recent 5-round average ‚Üí confidence decreases ‚Üí marketing scaled down.
  Else confidence edges up slightly.

Market trend (if enabled):
  trendEffect ‚àà { boom:+0.05, stable:0.00, recession:‚àí0.10 } drawn each round.
  </pre>

  <h4>3) Roles and intuition</h4>
  <ul>
    <li><b>Competitor</b>: increases demand penalty when your price exceeds theirs; higher <code>compIntensity</code> ‚Üí higher price sensitivity.</li>
    <li><b>Influencer Buzz</b>: converts last round‚Äôs buyers into extra ‚Äúfree marketing.‚Äù Good performance can snowball (but variance rises).</li>
    <li><b>Supplier Cost</b>: random per round; higher mean/volatility compress margins and widens the profit spread.</li>
    <li><b>Investor Confidence</b>: adaptive brake on marketing after weak profit; narrows downside but can mute rebounds.</li>
    <li><b>Market Trend</b>: boom/recession shocks shift demand baseline and add macro volatility.</li>
  </ul>

  <h4>4) Reading the charts</h4>
  <ul>
    <li><b>Main chart</b>: Profit & Total Buyers over time for one run (shows path-dependence/volatility).</li>
    <li><b>Round Analyzer</b>: Pick a round and see ŒîProfit/ŒîBuyers vs others to diagnose highs/lows.</li>
    <li><b>Monte Carlo (Mean ¬± 1œÉ)</b>: Repeats the same settings many times; plots mean profit per round with an uncertainty band.
      Tiles show the distribution of <i>average profit per run</i> (mean, std, 5‚Äì95%).</li>
    <li><b>Sensitivity</b>: Sweeps one role at a time (low/mid/high) and compares average profit across many runs.</li>
  </ul>

  <h4>5) Insights from multiple runs</h4>
  <ul>
    <li><b>Competition</b>: Higher <code>compIntensity</code> lowers mean profit and raises variance unless price stays close to the competitor.</li>
    <li><b>Marketing & Buzz</b>: There‚Äôs a sweet spot‚Äîmarketing has cost (‚âà 50√ómarketing). With buzz, the mean often rises but the œÉ band widens.</li>
    <li><b>Cost structure</b>: Raising <code>supplierMean</code> shifts profit downward nearly one-for-one; higher <code>supplierVol</code> inflates risk.</li>
    <li><b>Investor confidence</b>: Usually tightens the distribution (lower œÉ) by cutting marketing after weak rounds; peaks may be slightly lower.</li>
    <li><b>Trend shocks</b>: Add macro noise‚Äîboom improves profit, recession lowers it; turning trend OFF helps isolate policy changes.</li>
  </ul>

  <h4>6) Practical tuning workflow</h4>
  <ol>
    <li>Pick a baseline ‚Üí run <b>Monte Carlo</b> (e.g., R=60). Note Mean, œÉ, 5‚Äì95% of average profit.</li>
    <li>Use <b>Sensitivity</b> to find promising levers:
      <ul>
        <li>Reduce price gap or <code>compIntensity</code> to soften competition effects.</li>
        <li>Test <code>buzzStrength</code> for upside vs variance trade-off.</li>
        <li>Lower <code>supplierMean/Vol</code> if possible.</li>
        <li>Tune <code>confDecay</code> to balance stability vs agility.</li>
      </ul>
    </li>
    <li>Lock a candidate setup ‚Üí re-run <b>Monte Carlo</b> to confirm it‚Äôs robust (higher mean and/or tighter band).</li>
    <li>Use <b>Round Analyzer</b> to explain outliers (price, marketing, supplier cost, trend).</li>
  </ol>

  <h4>7) What ‚Äúgood‚Äù looks like</h4>
  <p>
    Prefer settings that raise the Monte Carlo <b>mean</b> while not exploding the <b>œÉ</b>.  
    If means are similar, choose the tighter band (lower downside risk).
  </p>

  <h4>8) Limits</h4>
  <ul>
    <li>Reduced-form demand (two segments, linear effects, clamping).</li>
    <li>Competitor/trend are exogenous (no full strategic learning/equilibrium).</li>
    <li>Buzz & confidence are simplified feedbacks without lags/saturation.</li>
  </ul>
</details>

       
    </div>
  </div>

  <script>
    // ---------- Helpers ----------
    const clamp = (x, lo, hi) => Math.max(lo, Math.min(hi, x));
    const rand = (a,b) => Math.random()*(b-a)+a;
    const choice = arr => arr[Math.floor(Math.random()*arr.length)];
    const mean = arr => arr.reduce((a,b)=>a+b,0) / (arr.length || 1);
    const std = arr => {
      const m = mean(arr);
      const v = mean(arr.map(x => (x-m)*(x-m)));
      return Math.sqrt(v);
    };
    const quantile = (arr, q) => {
      const a = [...arr].sort((x,y)=>x-y);
      const idx = (a.length-1)*q;
      const lo = Math.floor(idx), hi = Math.ceil(idx);
      if (lo === hi) return a[lo];
      return a[lo] + (a[hi]-a[lo])*(idx-lo);
    };

    class Segment {
      constructor(name, priceSens, mktSens, base=0.3){
        this.name=name; this.priceSens=priceSens; this.mktSens=mktSens; this.base=base;
      }
      buyProb(price, effMkt, relPricePenalty, trend){
        const p = this.base + this.mktSens*effMkt - this.priceSens*relPricePenalty + trend;
        return clamp(p,0,1);
      }
    }

    // ---------- Simulation ----------
    function simulate(params){
      const {
        rounds, startPrice, startMkt,
        useCompetitor, compIntensity,
        useInfluencer, buzzStrength,
        useSupplier, supplierMean, supplierVol,
        useInvestor, confDecay,
        useTrend
      } = params;

      // Consumers
      const segA = new Segment("A (price-sensitive)", 0.05, 0.15, 0.25);
      const segB = new Segment("B (brand-loyal)",     0.02, 0.08,  0.35);
      const segments=[segA, segB];

      let price=startPrice, marketing=startMkt;
      let competitorPrice = startPrice + rand(-0.5,0.5);
      let investorConf = 1.0;
      let totalBuyersPrev = 0;

      const out = { price:[], marketing:[], profit:[], buyers:[], perSeg:[], compPrice:[], invConf:[], suppCost:[], trend:[] };

      const trendMap = { boom: +0.05, stable: 0.0, recession: -0.10 };
      const profitWindow=[];

      for(let t=1;t<=rounds;t++){
        const trendState = useTrend ? choice(["boom","stable","recession"]) : "stable";
        const trendEffect = trendMap[trendState];

        price = clamp(price + rand(-0.3,0.3), 1, 999);
        marketing = clamp(marketing + rand(-0.05,0.05), 0, 1);

        if(useCompetitor){
          competitorPrice = clamp(competitorPrice + rand(-0.25,0.25), 1, 999);
        }

        const effMarketing = useInfluencer ? clamp(marketing + buzzStrength*(totalBuyersPrev/200), 0, 2) : marketing;
        const supplierCost = useSupplier ? clamp(supplierMean + rand(-supplierVol, supplierVol), 0, 10) : 0;

        let total=0; const segRows=[];
        for(const seg of segments){
          const relPricePenalty = useCompetitor ? (price - competitorPrice)*(1 + compIntensity*10) : price;
          const prob = seg.buyProb(price, effMarketing, relPricePenalty, trendEffect);
          let buyers=0; for(let i=0;i<100;i++){ if(Math.random()<prob) buyers++; }
          segRows.push({ name:seg.name, prob, buyers });
          total += buyers;
        }

        const revenue = total * price;
        const mktCost = 50 * marketing;
        const profit = (revenue - mktCost) - (supplierCost * total);

        profitWindow.push(profit); if(profitWindow.length>5) profitWindow.shift();
        const avgProfit = mean(profitWindow);
        if(useInvestor && profit < avgProfit){
          investorConf = clamp(investorConf - confDecay, 0.6, 1.2);
          marketing = clamp(marketing * investorConf, 0, 1);
        } else {
          investorConf = clamp(investorConf + confDecay*0.3, 0.6, 1.2);
        }

        out.price.push(price); out.marketing.push(marketing); out.profit.push(profit);
        out.buyers.push(total); out.perSeg.push(segRows);
        out.compPrice.push(competitorPrice); out.invConf.push(investorConf);
        out.suppCost.push(supplierCost); out.trend.push(trendState);

        totalBuyersPrev = total;
      }
      return out;
    }

    // ---------- Globals ----------
    let mainChart, sensChart, diffChart, mcChart;
    let lastResult = null;
    let lastParams = null;

    // ---------- Rendering (main) ----------
    function renderChart(data, selectedIndex = null){
      const ctx = document.getElementById('chart').getContext('2d');
      const labels = data.profit.map((_,i)=>`Round ${i+1}`);
      const pointR = data.profit.map((_,i)=> (i===selectedIndex ? 6 : 2));
      const ds = [
        { label:"Profit", data:data.profit, yAxisID:'y', pointRadius: pointR },
        { label:"Total Buyers", data:data.buyers, yAxisID:'y1' },
      ];
      if(mainChart) mainChart.destroy();
      mainChart = new Chart(ctx,{
        type:'line',
        data:{ labels, datasets: ds },
        options:{
          responsive:true, interaction:{ mode:'index', intersect:false },
          plugins:{ legend:{ position:'top' } },
          scales:{
            y:{ title:{ display:true, text:'Profit' } },
            y1:{ position:'right', grid:{ drawOnChartArea:false }, title:{ display:true, text:'Total Buyers' } }
          }
        }
      });
    }

    function renderSummary(data){
      const tbody = document.querySelector('#summary tbody'); tbody.innerHTML='';
      const n = data.profit.length-1;
      const rows = [
        ['Round', (n+1)],
        ['Price', data.price[n].toFixed(2)],
        ['Competitor Price', data.compPrice[n].toFixed(2)],
        ['Marketing', data.marketing[n].toFixed(2)],
        ['Supplier Cost', data.suppCost[n].toFixed(2)],
        ['Investor Confidence', data.invConf[n].toFixed(2)],
        ['Market Trend', data.trend[n]],
        ['Total Buyers', data.buyers[n]],
        ['Profit', data.profit[n].toFixed(2)],
        ['Seg A: P(buy), buyers', `${data.perSeg[n][0].prob.toFixed(2)}, ${data.perSeg[n][0].buyers}/100`],
        ['Seg B: P(buy), buyers', `${data.perSeg[n][1].prob.toFixed(2)}, ${data.perSeg[n][1].buyers}/100`],
      ];
      for(const [k,v] of rows){
        const tr=document.createElement('tr'); tr.innerHTML=`<th>${k}</th><td>${v}</td>`; tbody.appendChild(tr);
      }
    }

    function collectParamsFromUI(){
      return {
        rounds: +document.getElementById('rounds').value,
        startPrice: +document.getElementById('startPrice').value,
        startMkt: +document.getElementById('startMkt').value,
        useCompetitor: document.getElementById('useCompetitor').checked,
        compIntensity: +document.getElementById('compIntensity').value,
        useInfluencer: document.getElementById('useInfluencer').checked,
        buzzStrength: +document.getElementById('buzzStrength').value,
        useSupplier: document.getElementById('useSupplier').checked,
        supplierMean: +document.getElementById('supplierMean').value,
        supplierVol: +document.getElementById('supplierVol').value,
        useInvestor: document.getElementById('useInvestor').checked,
        confDecay: +document.getElementById('confDecay').value,
        useTrend: document.getElementById('useTrend').checked,
      };
    }

    function populateRoundSelector(nRounds){
      const sel = document.getElementById('roundSelect');
      sel.innerHTML = '';
      for(let i=1;i<=nRounds;i++){
        const opt = document.createElement('option');
        opt.value = i-1; // zero-based index
        opt.textContent = `Round ${i}`;
        sel.appendChild(opt);
      }
    }

    function runSim(){
      const params = collectParamsFromUI();
      const result = simulate(params);
      lastResult = result; lastParams = params;
      renderChart(result, null);
      renderSummary(result);
      populateRoundSelector(result.profit.length);
      if(diffChart){ diffChart.destroy(); diffChart=null; }
    }

    // ---------- Round Analyzer ----------
    function analyzeSelectedRound(){
      if(!lastResult) return;
      const baseIdx = +document.getElementById('roundSelect').value;
      const pr = lastResult.profit, brs = lastResult.buyers;
      const diffProfit = pr.map((v)=> v - pr[baseIdx]);
      const diffBuyers = brs.map((v)=> v - brs[baseIdx]);
      renderChart(lastResult, baseIdx);
      const ctx = document.getElementById('diffChart').getContext('2d');
      const labels = pr.map((_,i)=>`R${i+1}`);
      if(diffChart) diffChart.destroy();
      diffChart = new Chart(ctx, {
        type:'bar',
        data:{
          labels,
          datasets:[
            { label:`Œî Profit vs R${baseIdx+1}`, data: diffProfit },
            { label:`Œî Buyers vs R${baseIdx+1}`, data: diffBuyers }
          ]
        },
        options:{
          responsive:true,
          plugins:{ legend:{ position:'top' } },
          scales:{ y:{ title:{ display:true, text:'Difference' } } }
        }
      });
    }

    // ---------- Monte Carlo (NEW) ----------
    function runMonteCarlo(){
      const R = Math.max(5, Math.min(500, +document.getElementById('mcRuns').value || 60));
      const base = collectParamsFromUI();
      const rounds = base.rounds;

      // accumulate per-round sums and sums of squares
      const sum = Array(rounds).fill(0);
      const sumsq = Array(rounds).fill(0);
      const perRunAvg = []; // average profit per run

      for(let r=0; r<R; r++){
        const res = simulate(base);
        const avgP = mean(res.profit);
        perRunAvg.push(avgP);
        for(let i=0;i<rounds;i++){
          const p = res.profit[i];
          sum[i] += p; sumsq[i] += p*p;
        }
      }

      const meanPerRound = sum.map(v => v / R);
      const stdPerRound  = sumsq.map((v,i) => Math.sqrt(Math.max(0, v/R - meanPerRound[i]*meanPerRound[i])));

      // Overall stats on "average profit per run"
      const mcMean = mean(perRunAvg);
      const mcStd  = std(perRunAvg);
      const mcP05  = quantile(perRunAvg, 0.05);
      const mcP95  = quantile(perRunAvg, 0.95);

      // update tiles
      document.getElementById('mcMean').textContent = mcMean.toFixed(2);
      document.getElementById('mcStd').textContent  = mcStd.toFixed(2);
      document.getElementById('mcP05').textContent  = mcP05.toFixed(2);
      document.getElementById('mcP95').textContent  = mcP95.toFixed(2);

      // render mean ¬±1œÉ band chart
      const upper = meanPerRound.map((m,i)=> m + stdPerRound[i]);
      const lower = meanPerRound.map((m,i)=> m - stdPerRound[i]);
      const labels = meanPerRound.map((_,i)=>`Round ${i+1}`);

      const ctx = document.getElementById('mcChart').getContext('2d');
      if(mcChart) mcChart.destroy();

      // trick: draw lower first, then upper filled to previous, then mean line on top
      mcChart = new Chart(ctx, {
        type:'line',
        data:{
          labels,
          datasets:[
            {
              label:'-1œÉ',
              data: lower,
              borderColor: 'rgba(0,0,0,0)',
              backgroundColor: 'rgba(37, 99, 235, 0.10)', // fill color
            },
            {
              label:'+1œÉ',
              data: upper,
              borderColor: 'rgba(0,0,0,0)',
              backgroundColor: 'rgba(37, 99, 235, 0.10)',
              fill: '-1' // fill to the previous dataset (lower)
            },
            {
              label:'Mean Profit (per round)',
              data: meanPerRound,
              borderColor: '#2563eb',
              pointRadius: 2,
            }
          ]
        },
        options:{
          responsive:true,
          interaction:{ mode:'index', intersect:false },
          plugins:{ legend:{ position:'top' } },
          scales:{ y:{ title:{ display:true, text:'Profit' } } }
        }
      });
    }

    // ---------- Sensitivity Analysis (kept) ----------
    function simulateAvgProfit(params, repeats=20){
      const profits = [];
      for(let i=0;i<repeats;i++){
        const r = simulate(params);
        profits.push( mean(r.profit) );
      }
      return mean(profits);
    }

    function runSensitivity(){
      const base = collectParamsFromUI();
      const compVals = [0.00, 0.04, 0.08];
      const buzzVals = [0.00, 0.15, 0.30];
      const suppMeanVals = [0.6, 1.0, 1.4];
      const invDecayVals = [0.00, 0.05, 0.10];
      const trendVals = [false, true];

      const labels = [];
      const values = [];

      compVals.forEach(v=>{
        const p = { ...base, useCompetitor:true, compIntensity:v };
        labels.push(`Competitor ${v.toFixed(2)}`);
        values.push( simulateAvgProfit(p, 20) );
      });

      buzzVals.forEach(v=>{
        const p = { ...base, useInfluencer:true, buzzStrength:v };
        labels.push(`Influencer ${v.toFixed(2)}`);
        values.push( simulateAvgProfit(p, 20) );
      });

      suppMeanVals.forEach(v=>{
        const p = { ...base, useSupplier:true, supplierMean:v };
        labels.push(`Supplier Mean ${v.toFixed(1)}`);
        values.push( simulateAvgProfit(p, 20) );
      });

      invDecayVals.forEach(v=>{
        const p = { ...base, useInvestor:true, confDecay:v };
        labels.push(`Investor Decay ${v.toFixed(2)}`);
        values.push( simulateAvgProfit(p, 20) );
      });

      trendVals.forEach(v=>{
        const p = { ...base, useTrend:v };
        labels.push(`Trend ${v ? 'On' : 'Off'}`);
        values.push( simulateAvgProfit(p, 20) );
      });

      const ctx = document.getElementById('sensChart').getContext('2d');
      if(sensChart) sensChart.destroy();
      sensChart = new Chart(ctx, {
        type:'bar',
        data:{ labels, datasets:[{ label:'Average Profit (across rounds & runs)', data: values }] },
        options:{
          responsive:true,
          plugins:{ legend:{ display:true, position:'top' } },
          scales:{
            y:{ title:{ display:true, text:'Average Profit' } },
            x:{ ticks:{ maxRotation: 70, minRotation: 0 } }
          }
        }
      });
    }

    // auto-run on load
    window.addEventListener('DOMContentLoaded', runSim);
  </script>
</body>
</html>

<section id="project">
  <h3>üß≠ Development Progress</h3>
  <p>Follow updates and new features of the Sequential Consumer Game on GitHub:</p>
  <a href="https://github.com/users/ozhao8509-cyber/projects"
     target="_blank"
     style="color:#0078d4; text-decoration:none; font-weight:bold;">
     üîó View Project Board ‚Üí
  </a>
</section>






  <footer>
    <small>¬© 2025 Oscar Zhao</small>
  </footer>
</body>
</html>




